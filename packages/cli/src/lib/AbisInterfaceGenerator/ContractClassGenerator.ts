import { type AbiFunctionItem, AssemblyPrimitiveTypes, LibTypes } from '../../types'

import AbiTypeConverter from './AbiTypeConverter'
import FunctionHandler from './FunctionHandler'
import ImportManager from './ImportManager'
import NameManager from './NameManager'
import TupleHandler from './TupleHandler'
import type { TupleDefinitionsMap } from './types'

export default class ContractClassGenerator {
  private abi: AbiFunctionItem[]
  private importManager: ImportManager
  private tupleDefinitions: TupleDefinitionsMap
  private abiTypeConverter: AbiTypeConverter

  constructor(abi: AbiFunctionItem[]) {
    this.abi = abi
    this.importManager = new ImportManager()
    this.tupleDefinitions = TupleHandler.extractTupleDefinitions(this.abi)
    this.abiTypeConverter = new AbiTypeConverter(this.importManager, this.tupleDefinitions)
  }

  public generate(contractName: string): string {
    const mainClassCode = this.generateMainClass(contractName)
    const tupleClassesCode = TupleHandler.generateTupleClassesCode(
      this.tupleDefinitions,
      this.importManager,
      this.abiTypeConverter
    )
    // Note: this should be generated after any other generation
    const importsCode = this.importManager.generateImportsCode()

    const notice = '// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE MANUALLY.'

    const separator = '\n\n'
    let result = notice + separator + importsCode + separator + mainClassCode
    if (tupleClassesCode) result += separator + tupleClassesCode

    return result.trim()
  }

  private generateMainClass(contractName: string): string {
    const lines: string[] = []
    this.appendClassDefinition(lines, contractName)

    const functions = NameManager.resolveMethodNames(this.getFunctions())

    functions.forEach((fn) =>
      FunctionHandler.appendMethod(lines, fn, this.importManager, this.tupleDefinitions, this.abiTypeConverter)
    )
    lines.push('}')
    return lines.join('\n')
  }

  private appendClassDefinition(lines: string[], contractName: string): void {
    this.importManager.addType(LibTypes.Address)
    this.importManager.addType(LibTypes.ChainId)

    lines.push(`export class ${contractName} {`)
    lines.push(`  private _address: ${LibTypes.Address}`)
    lines.push(`  private _chainId: ${LibTypes.ChainId}`)
    lines.push(`  private _timestamp: ${AssemblyPrimitiveTypes.Date} | null`)
    lines.push('')
    lines.push(
      `  constructor(address: ${LibTypes.Address}, chainId: ${LibTypes.ChainId}, timestamp: ${AssemblyPrimitiveTypes.Date} | null = null) {`
    )
    lines.push(`    this._address = address`)
    lines.push(`    this._chainId = chainId`)
    lines.push(`    this._timestamp = timestamp`)
    lines.push(`  }`)
    lines.push('')
    lines.push(`  get address(): ${LibTypes.Address} {`)
    lines.push(`    return this._address.clone()`)
    lines.push(`  }`)
    lines.push('')
    lines.push(`  get chainId(): ${LibTypes.ChainId} {`)
    lines.push(`    return this._chainId`)
    lines.push(`  }`)
    lines.push('')
    lines.push(`  get timestamp(): ${AssemblyPrimitiveTypes.Date} | null {`)
    lines.push(
      `    return this._timestamp ? new ${AssemblyPrimitiveTypes.Date}(changetype<${AssemblyPrimitiveTypes.Date}>(this._timestamp).getTime()) : null`
    )
    lines.push(`  }`)
    lines.push('')
  }

  private getFunctions(): AbiFunctionItem[] {
    return this.abi.filter((item) => item.type === 'function')
  }
}
