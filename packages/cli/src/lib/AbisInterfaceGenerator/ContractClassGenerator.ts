import { type AbiFunctionItem, AssemblyPrimitiveTypes, LibTypes } from '../../types'

import AbiTypeConverter from './AbiTypeConverter'
import FunctionHandler from './FunctionHandler'
import ImportManager from './ImportManager'
import NameManager from './NameManager'
import TupleHandler from './TupleHandler'
import type { TupleDefinitionsMap } from './types'
import UtilsHandler from './UtilsHandler'

export default class ContractClassGenerator {
  private abi: AbiFunctionItem[]
  private importManager: ImportManager
  private tupleDefinitions: TupleDefinitionsMap
  private abiTypeConverter: AbiTypeConverter

  constructor(abi: AbiFunctionItem[]) {
    this.abi = abi
    this.importManager = new ImportManager()
    this.tupleDefinitions = TupleHandler.extractTupleDefinitions(this.abi)
    this.abiTypeConverter = new AbiTypeConverter(this.importManager, this.tupleDefinitions)
  }

  public generate(contractName: string): string {
    const functions = NameManager.resolveMethodNames(this.getFunctions())

    const mainClassCode = this.generateMainClass(contractName, functions)
    const utilsClassCode = this.generateUtilsClass(contractName, functions)
    const tupleClassesCode = TupleHandler.generateTupleClassesCode(
      this.tupleDefinitions,
      this.importManager,
      this.abiTypeConverter
    )
    // Note: this should be generated after any other generation
    const importsCode = this.importManager.generateImportsCode()

    const notice = '// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE MANUALLY.'

    const separator = '\n\n'
    let result = notice + separator + importsCode
    result += separator + mainClassCode
    result += separator + utilsClassCode
    if (tupleClassesCode) result += separator + tupleClassesCode

    return result.trim()
  }

  private generateMainClass(contractName: string, functions: AbiFunctionItem[]): string {
    const lines: string[] = []
    this.appendClassDefinition(lines, contractName)

    functions.forEach((fn) =>
      FunctionHandler.appendMethod(
        lines,
        fn,
        this.importManager,
        this.tupleDefinitions,
        this.abiTypeConverter,
        contractName
      )
    )
    lines.push('}')
    return lines.join('\n')
  }

  private generateUtilsClass(contractName: string, functions: AbiFunctionItem[]): string {
    return UtilsHandler.generate(
      contractName,
      functions,
      this.importManager,
      this.tupleDefinitions,
      this.abiTypeConverter
    )
  }

  private appendClassDefinition(lines: string[], contractName: string): void {
    this.importManager.addType(LibTypes.Address)
    this.importManager.addType(LibTypes.ChainId)

    lines.push(`export class ${contractName} {`)
    lines.push(`  private _address: ${LibTypes.Address}`)
    lines.push(`  private _chainId: ${LibTypes.ChainId}`)
    lines.push(`  private _timestamp: ${AssemblyPrimitiveTypes.Date} | null`)
    lines.push('')
    lines.push(
      `  constructor(address: ${LibTypes.Address}, chainId: ${LibTypes.ChainId}, timestamp: ${AssemblyPrimitiveTypes.Date} | null = null) {`
    )
    lines.push(`    this._address = address`)
    lines.push(`    this._chainId = chainId`)
    lines.push(`    this._timestamp = timestamp`)
    lines.push(`  }`)
    lines.push('')
    lines.push(`  get address(): ${LibTypes.Address} {`)
    lines.push(`    return this._address.clone()`)
    lines.push(`  }`)
    lines.push('')
    lines.push(`  get chainId(): ${LibTypes.ChainId} {`)
    lines.push(`    return this._chainId`)
    lines.push(`  }`)
    lines.push('')
    lines.push(`  get timestamp(): ${AssemblyPrimitiveTypes.Date} | null {`)
    lines.push(
      `    return this._timestamp ? new ${AssemblyPrimitiveTypes.Date}(changetype<${AssemblyPrimitiveTypes.Date}>(this._timestamp).getTime()) : null`
    )
    lines.push(`  }`)
    lines.push('')
  }

  private getFunctions(): AbiFunctionItem[] {
    return this.abi.filter((item) => item.type === 'function')
  }
}
