use anyhow::Result;
use std::convert::TryInto;
use wasmtime::Caller;

/// Reads a string from the WebAssembly memory generated by AssemblyScript.
///
/// AssemblyScript places a 4-byte integer immediately before the string pointer.
/// That integer indicates the size of the data following the header
/// By default it uses utf-16 encoding for strings
///
/// Returns an error if the "memory" export is not found or if the memory bounds are exceeded.
pub fn read_string_from_memory(caller: &mut Caller<'_, ()>, ptr: i32) -> Result<String> {
    let data = caller
        .get_export("memory")
        .ok_or_else(|| anyhow::anyhow!("Memory export not found"))?
        .into_memory()
        .ok_or_else(|| anyhow::anyhow!("Failed to get memory from export"))?
        .data(caller);
    read_string_from_data(data, ptr)
}

pub fn read_string_from_data(data: &[u8], ptr: i32) -> Result<String> {
    let ptr = ptr as usize;
    if ptr < 4 {
        return Err(anyhow::anyhow!("Pointer out of memory bounds, too small"));
    }
    if ptr > data.len() - 4 {
        return Err(anyhow::anyhow!("Pointer out of memory bounds, too big"));
    }

    let length = get_length_header(data, ptr)?;
    let raw = &data
        .get(ptr..ptr + length)
        .ok_or_else(|| anyhow::anyhow!("Memory bounds exceeded"))?;

    raw_utf16_to_string(raw)
}

fn get_length_header(data: &[u8], ptr: usize) -> Result<usize> {
    let header_bytes: [u8; 4] = data[ptr - 4..ptr]
        .try_into()
        .map_err(|_| anyhow::anyhow!("Failed to convert length header bytes"))?;

    Ok(u32::from_le_bytes(header_bytes) as usize)
}

fn raw_utf16_to_string(raw: &[u8]) -> Result<String> {
    let code_units: Vec<u16> = raw
        .chunks_exact(2)
        .map(|chunk| u16::from_le_bytes(chunk.try_into().unwrap()))
        .collect();
    String::from_utf16(&code_units)
        .map_err(|e| anyhow::anyhow!("Failed to convert to UTF-16: {}", e))
}
