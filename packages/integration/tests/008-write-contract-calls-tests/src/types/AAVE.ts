// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE MANUALLY.

import {
  Address,
  BigInt,
  Bytes,
  CallBuilder,
  ChainId,
  environment,
  evm,
  EvmDecodeParam,
  EvmEncodeParam,
  parseCSVNotNullable,
} from '@mimicprotocol/lib-ts'

export class AAVE {
  private _address: Address
  private _chainId: ChainId
  private _timestamp: Date | null

  constructor(address: Address, chainId: ChainId, timestamp: Date | null = null) {
    this._address = address
    this._chainId = chainId
    this._timestamp = timestamp
  }

  get address(): Address {
    return this._address.clone()
  }

  get chainId(): ChainId {
    return this._chainId
  }

  get timestamp(): Date | null {
    return this._timestamp ? new Date(changetype<Date>(this._timestamp).getTime()) : null
  }

  ADDRESSES_PROVIDER(): Address {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x0542975c')
    const decodedResponse = evm.decode(new EvmDecodeParam('address', response))
    return Address.fromString(decodedResponse)
  }

  BRIDGE_PROTOCOL_FEE(): BigInt {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x272d9072')
    const decodedResponse = evm.decode(new EvmDecodeParam('uint256', response))
    return BigInt.fromString(decodedResponse)
  }

  FLASHLOAN_PREMIUM_TOTAL(): BigInt {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x074b2e43')
    const decodedResponse = evm.decode(new EvmDecodeParam('uint128', response))
    return BigInt.fromString(decodedResponse)
  }

  FLASHLOAN_PREMIUM_TO_PROTOCOL(): BigInt {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x6a99c036')
    const decodedResponse = evm.decode(new EvmDecodeParam('uint128', response))
    return BigInt.fromString(decodedResponse)
  }

  MAX_NUMBER_RESERVES(): u16 {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0xf8119d51')
    const decodedResponse = evm.decode(new EvmDecodeParam('uint16', response))
    return u16.parse(decodedResponse)
  }

  POOL_REVISION(): BigInt {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x0148170e')
    const decodedResponse = evm.decode(new EvmDecodeParam('uint256', response))
    return BigInt.fromString(decodedResponse)
  }

  backUnbacked(asset: Address, amount: BigInt, fee: BigInt): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0xd65dc7a1' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('uint256', amount),
          EvmEncodeParam.fromValue('uint256', fee),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  borrow(
    asset: Address,
    amount: BigInt,
    interestRateMode: BigInt,
    referralCode: u16,
    onBehalfOf: Address
  ): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0xa415bcad' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('uint256', amount),
          EvmEncodeParam.fromValue('uint256', interestRateMode),
          EvmEncodeParam.fromValue('uint16', BigInt.fromU16(referralCode)),
          EvmEncodeParam.fromValue('address', onBehalfOf),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  borrow_1(args: Bytes): CallBuilder {
    const encodedData = Bytes.fromHexString('0xd5eed868' + evm.encode([EvmEncodeParam.fromValue('bytes32', args)]))
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  configureEModeCategory(id: u8, category: EModeCategoryBaseConfiguration): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x7b75d7f4' +
        evm.encode([
          EvmEncodeParam.fromValue('uint8', BigInt.fromU8(id)),
          EvmEncodeParam.fromValues('()', category.toEvmEncodeParams()),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  configureEModeCategoryBorrowableBitmap(id: u8, borrowableBitmap: BigInt): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0xff72158a' +
        evm.encode([
          EvmEncodeParam.fromValue('uint8', BigInt.fromU8(id)),
          EvmEncodeParam.fromValue('uint128', borrowableBitmap),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  configureEModeCategoryCollateralBitmap(id: u8, collateralBitmap: BigInt): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x92380ecb' +
        evm.encode([
          EvmEncodeParam.fromValue('uint8', BigInt.fromU8(id)),
          EvmEncodeParam.fromValue('uint128', collateralBitmap),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  deposit(asset: Address, amount: BigInt, onBehalfOf: Address, referralCode: u16): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0xe8eda9df' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('uint256', amount),
          EvmEncodeParam.fromValue('address', onBehalfOf),
          EvmEncodeParam.fromValue('uint16', BigInt.fromU16(referralCode)),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  dropReserve(asset: Address): CallBuilder {
    const encodedData = Bytes.fromHexString('0x63c9b860' + evm.encode([EvmEncodeParam.fromValue('address', asset)]))
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  finalizeTransfer(
    asset: Address,
    from: Address,
    to: Address,
    amount: BigInt,
    balanceFromBefore: BigInt,
    balanceToBefore: BigInt
  ): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0xd5ed3933' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('address', from),
          EvmEncodeParam.fromValue('address', to),
          EvmEncodeParam.fromValue('uint256', amount),
          EvmEncodeParam.fromValue('uint256', balanceFromBefore),
          EvmEncodeParam.fromValue('uint256', balanceToBefore),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  flashLoan(
    receiverAddress: Address,
    assets: Address[],
    amounts: BigInt[],
    interestRateModes: BigInt[],
    onBehalfOf: Address,
    params: Bytes,
    referralCode: u16
  ): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0xab9c4b5d' +
        evm.encode([
          EvmEncodeParam.fromValue('address', receiverAddress),
          EvmEncodeParam.fromValues(
            'address[]',
            assets.map<EvmEncodeParam>((s0) => EvmEncodeParam.fromValue('address', s0))
          ),
          EvmEncodeParam.fromValues(
            'uint256[]',
            amounts.map<EvmEncodeParam>((s0) => EvmEncodeParam.fromValue('uint256', s0))
          ),
          EvmEncodeParam.fromValues(
            'uint256[]',
            interestRateModes.map<EvmEncodeParam>((s0) => EvmEncodeParam.fromValue('uint256', s0))
          ),
          EvmEncodeParam.fromValue('address', onBehalfOf),
          EvmEncodeParam.fromValue('bytes', params),
          EvmEncodeParam.fromValue('uint16', BigInt.fromU16(referralCode)),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  flashLoanSimple(
    receiverAddress: Address,
    asset: Address,
    amount: BigInt,
    params: Bytes,
    referralCode: u16
  ): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x42b0b77c' +
        evm.encode([
          EvmEncodeParam.fromValue('address', receiverAddress),
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('uint256', amount),
          EvmEncodeParam.fromValue('bytes', params),
          EvmEncodeParam.fromValue('uint16', BigInt.fromU16(referralCode)),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  getBorrowLogic(): Address {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x2be29fa7')
    const decodedResponse = evm.decode(new EvmDecodeParam('address', response))
    return Address.fromString(decodedResponse)
  }

  getBridgeLogic(): Address {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0xdf374c36')
    const decodedResponse = evm.decode(new EvmDecodeParam('address', response))
    return Address.fromString(decodedResponse)
  }

  getConfiguration(asset: Address): ReserveConfigurationMap {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0xc44b11f7' + evm.encode([EvmEncodeParam.fromValue('address', asset)])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('(uint256)', response))
    return ReserveConfigurationMap.parse(decodedResponse)
  }

  getEModeCategoryBorrowableBitmap(id: u8): BigInt {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0x903a2c71' + evm.encode([EvmEncodeParam.fromValue('uint8', BigInt.fromU8(id))])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('uint128', response))
    return BigInt.fromString(decodedResponse)
  }

  getEModeCategoryCollateralBitmap(id: u8): BigInt {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0xb0771dba' + evm.encode([EvmEncodeParam.fromValue('uint8', BigInt.fromU8(id))])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('uint128', response))
    return BigInt.fromString(decodedResponse)
  }

  getEModeCategoryCollateralConfig(id: u8): CollateralConfig {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0xb286f467' + evm.encode([EvmEncodeParam.fromValue('uint8', BigInt.fromU8(id))])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('(uint16,uint16,uint16)', response))
    return CollateralConfig.parse(decodedResponse)
  }

  getEModeCategoryData(id: u8): EModeCategoryLegacy {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0x6c6f6ae1' + evm.encode([EvmEncodeParam.fromValue('uint8', BigInt.fromU8(id))])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('(uint16,uint16,uint16,address,string)', response))
    return EModeCategoryLegacy.parse(decodedResponse)
  }

  getEModeCategoryLabel(id: u8): string {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0x2083e183' + evm.encode([EvmEncodeParam.fromValue('uint8', BigInt.fromU8(id))])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('string', response))
    return decodedResponse
  }

  getEModeLogic(): Address {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0xf32b9a73')
    const decodedResponse = evm.decode(new EvmDecodeParam('address', response))
    return Address.fromString(decodedResponse)
  }

  getFlashLoanLogic(): Address {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x348fde0f')
    const decodedResponse = evm.decode(new EvmDecodeParam('address', response))
    return Address.fromString(decodedResponse)
  }

  getLiquidationGracePeriod(asset: Address): CallBuilder {
    const encodedData = Bytes.fromHexString('0x5c9a8b18' + evm.encode([EvmEncodeParam.fromValue('address', asset)]))
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  getLiquidationLogic(): Address {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x911a3413')
    const decodedResponse = evm.decode(new EvmDecodeParam('address', response))
    return Address.fromString(decodedResponse)
  }

  getPoolLogic(): Address {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0xd3350155')
    const decodedResponse = evm.decode(new EvmDecodeParam('address', response))
    return Address.fromString(decodedResponse)
  }

  getReserveAddressById(id: u16): Address {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0x52751797' + evm.encode([EvmEncodeParam.fromValue('uint16', BigInt.fromU16(id))])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('address', response))
    return Address.fromString(decodedResponse)
  }

  getReserveData(asset: Address): ReserveDataLegacy {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0x35ea6a75' + evm.encode([EvmEncodeParam.fromValue('address', asset)])
    )
    const decodedResponse = evm.decode(
      new EvmDecodeParam(
        '((uint256),uint128,uint128,uint128,uint128,uint128,uint40,uint16,address,address,address,address,uint128,uint128,uint128)',
        response
      )
    )
    return ReserveDataLegacy.parse(decodedResponse)
  }

  getReserveDataExtended(asset: Address): ReserveData {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0x8381995f' + evm.encode([EvmEncodeParam.fromValue('address', asset)])
    )
    const decodedResponse = evm.decode(
      new EvmDecodeParam(
        '((uint256),uint128,uint128,uint128,uint128,uint128,uint40,uint16,uint40,address,address,address,address,uint128,uint128,uint128,uint128)',
        response
      )
    )
    return ReserveData.parse(decodedResponse)
  }

  getReserveNormalizedIncome(asset: Address): BigInt {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0xd15e0053' + evm.encode([EvmEncodeParam.fromValue('address', asset)])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('uint256', response))
    return BigInt.fromString(decodedResponse)
  }

  getReserveNormalizedVariableDebt(asset: Address): BigInt {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0x386497fd' + evm.encode([EvmEncodeParam.fromValue('address', asset)])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('uint256', response))
    return BigInt.fromString(decodedResponse)
  }

  getReservesCount(): BigInt {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x72218d04')
    const decodedResponse = evm.decode(new EvmDecodeParam('uint256', response))
    return BigInt.fromString(decodedResponse)
  }

  getReservesList(): Address[] {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0xd1946dbc')
    const decodedResponse = evm.decode(new EvmDecodeParam('address[]', response))
    return decodedResponse === ''
      ? []
      : parseCSVNotNullable(decodedResponse).map<Address>((item0: string) => Address.fromString(item0))
  }

  getSupplyLogic(): Address {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x870e7744')
    const decodedResponse = evm.decode(new EvmDecodeParam('address', response))
    return Address.fromString(decodedResponse)
  }

  getUserAccountData(user: Address): GetUserAccountDataOutputs {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0xbf92857c' + evm.encode([EvmEncodeParam.fromValue('address', user)])
    )
    const decodedResponse = evm.decode(
      new EvmDecodeParam('(uint256,uint256,uint256,uint256,uint256,uint256)', response)
    )
    return GetUserAccountDataOutputs.parse(decodedResponse)
  }

  getUserConfiguration(user: Address): ReserveConfigurationMap {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0x4417a583' + evm.encode([EvmEncodeParam.fromValue('address', user)])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('(uint256)', response))
    return ReserveConfigurationMap.parse(decodedResponse)
  }

  getUserEMode(user: Address): BigInt {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0xeddf1b79' + evm.encode([EvmEncodeParam.fromValue('address', user)])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('uint256', response))
    return BigInt.fromString(decodedResponse)
  }

  getVirtualUnderlyingBalance(asset: Address): BigInt {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0x6fb07f96' + evm.encode([EvmEncodeParam.fromValue('address', asset)])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('uint128', response))
    return BigInt.fromString(decodedResponse)
  }

  initReserve(
    asset: Address,
    aTokenAddress: Address,
    variableDebtAddress: Address,
    interestRateStrategyAddress: Address
  ): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x8bd25677' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('address', aTokenAddress),
          EvmEncodeParam.fromValue('address', variableDebtAddress),
          EvmEncodeParam.fromValue('address', interestRateStrategyAddress),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  initialize(provider: Address): CallBuilder {
    const encodedData = Bytes.fromHexString('0xc4d66de8' + evm.encode([EvmEncodeParam.fromValue('address', provider)]))
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  liquidationCall(
    collateralAsset: Address,
    debtAsset: Address,
    user: Address,
    debtToCover: BigInt,
    receiveAToken: bool
  ): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x00a718a9' +
        evm.encode([
          EvmEncodeParam.fromValue('address', collateralAsset),
          EvmEncodeParam.fromValue('address', debtAsset),
          EvmEncodeParam.fromValue('address', user),
          EvmEncodeParam.fromValue('uint256', debtToCover),
          EvmEncodeParam.fromValue('bool', Bytes.fromBool(receiveAToken)),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  liquidationCall_1(args1: Bytes, args2: Bytes): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0xfd21ecff' +
        evm.encode([EvmEncodeParam.fromValue('bytes32', args1), EvmEncodeParam.fromValue('bytes32', args2)])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  mintToTreasury(assets: Address[]): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x9cd19996' +
        evm.encode([
          EvmEncodeParam.fromValues(
            'address[]',
            assets.map<EvmEncodeParam>((s0) => EvmEncodeParam.fromValue('address', s0))
          ),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  mintUnbacked(asset: Address, amount: BigInt, onBehalfOf: Address, referralCode: u16): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x69a933a5' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('uint256', amount),
          EvmEncodeParam.fromValue('address', onBehalfOf),
          EvmEncodeParam.fromValue('uint16', BigInt.fromU16(referralCode)),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  repay(args: Bytes): CallBuilder {
    const encodedData = Bytes.fromHexString('0x563dd613' + evm.encode([EvmEncodeParam.fromValue('bytes32', args)]))
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  repay_1(asset: Address, amount: BigInt, interestRateMode: BigInt, onBehalfOf: Address): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x573ade81' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('uint256', amount),
          EvmEncodeParam.fromValue('uint256', interestRateMode),
          EvmEncodeParam.fromValue('address', onBehalfOf),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  repayWithATokens(asset: Address, amount: BigInt, interestRateMode: BigInt): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x2dad97d4' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('uint256', amount),
          EvmEncodeParam.fromValue('uint256', interestRateMode),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  repayWithATokens_1(args: Bytes): CallBuilder {
    const encodedData = Bytes.fromHexString('0xdc7c0bff' + evm.encode([EvmEncodeParam.fromValue('bytes32', args)]))
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  repayWithPermit(args: Bytes, r: Bytes, s: Bytes): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x94b576de' +
        evm.encode([
          EvmEncodeParam.fromValue('bytes32', args),
          EvmEncodeParam.fromValue('bytes32', r),
          EvmEncodeParam.fromValue('bytes32', s),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  repayWithPermit_1(
    asset: Address,
    amount: BigInt,
    interestRateMode: BigInt,
    onBehalfOf: Address,
    deadline: BigInt,
    permitV: u8,
    permitR: Bytes,
    permitS: Bytes
  ): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0xee3e210b' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('uint256', amount),
          EvmEncodeParam.fromValue('uint256', interestRateMode),
          EvmEncodeParam.fromValue('address', onBehalfOf),
          EvmEncodeParam.fromValue('uint256', deadline),
          EvmEncodeParam.fromValue('uint8', BigInt.fromU8(permitV)),
          EvmEncodeParam.fromValue('bytes32', permitR),
          EvmEncodeParam.fromValue('bytes32', permitS),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  rescueTokens(token: Address, to: Address, amount: BigInt): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0xcea9d26f' +
        evm.encode([
          EvmEncodeParam.fromValue('address', token),
          EvmEncodeParam.fromValue('address', to),
          EvmEncodeParam.fromValue('uint256', amount),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  resetIsolationModeTotalDebt(asset: Address): CallBuilder {
    const encodedData = Bytes.fromHexString('0xe43e88a1' + evm.encode([EvmEncodeParam.fromValue('address', asset)]))
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  setConfiguration(asset: Address, configuration: ReserveConfigurationMap): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0xf51e435b' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValues('()', configuration.toEvmEncodeParams()),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  setLiquidationGracePeriod(asset: Address, until: BigInt): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0xb1a99e26' + evm.encode([EvmEncodeParam.fromValue('address', asset), EvmEncodeParam.fromValue('uint40', until)])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  setReserveInterestRateStrategyAddress(asset: Address, rateStrategyAddress: Address): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x1d2118f9' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('address', rateStrategyAddress),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  setUserEMode(categoryId: u8): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x28530a47' + evm.encode([EvmEncodeParam.fromValue('uint8', BigInt.fromU8(categoryId))])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  setUserUseReserveAsCollateral(args: Bytes): CallBuilder {
    const encodedData = Bytes.fromHexString('0x4d013f03' + evm.encode([EvmEncodeParam.fromValue('bytes32', args)]))
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  setUserUseReserveAsCollateral_1(asset: Address, useAsCollateral: bool): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x5a3b74b9' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('bool', Bytes.fromBool(useAsCollateral)),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  supply(asset: Address, amount: BigInt, onBehalfOf: Address, referralCode: u16): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x617ba037' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('uint256', amount),
          EvmEncodeParam.fromValue('address', onBehalfOf),
          EvmEncodeParam.fromValue('uint16', BigInt.fromU16(referralCode)),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  supply_1(args: Bytes): CallBuilder {
    const encodedData = Bytes.fromHexString('0xf7a73840' + evm.encode([EvmEncodeParam.fromValue('bytes32', args)]))
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  supplyWithPermit(
    asset: Address,
    amount: BigInt,
    onBehalfOf: Address,
    referralCode: u16,
    deadline: BigInt,
    permitV: u8,
    permitR: Bytes,
    permitS: Bytes
  ): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x02c205f0' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('uint256', amount),
          EvmEncodeParam.fromValue('address', onBehalfOf),
          EvmEncodeParam.fromValue('uint16', BigInt.fromU16(referralCode)),
          EvmEncodeParam.fromValue('uint256', deadline),
          EvmEncodeParam.fromValue('uint8', BigInt.fromU8(permitV)),
          EvmEncodeParam.fromValue('bytes32', permitR),
          EvmEncodeParam.fromValue('bytes32', permitS),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  supplyWithPermit_1(args: Bytes, r: Bytes, s: Bytes): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x680dd47c' +
        evm.encode([
          EvmEncodeParam.fromValue('bytes32', args),
          EvmEncodeParam.fromValue('bytes32', r),
          EvmEncodeParam.fromValue('bytes32', s),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  syncIndexesState(asset: Address): CallBuilder {
    const encodedData = Bytes.fromHexString('0xab2b51f6' + evm.encode([EvmEncodeParam.fromValue('address', asset)]))
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  syncRatesState(asset: Address): CallBuilder {
    const encodedData = Bytes.fromHexString('0x98c7da4e' + evm.encode([EvmEncodeParam.fromValue('address', asset)]))
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  updateBridgeProtocolFee(protocolFee: BigInt): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x3036b439' + evm.encode([EvmEncodeParam.fromValue('uint256', protocolFee)])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  updateFlashloanPremiums(flashLoanPremiumTotal: BigInt, flashLoanPremiumToProtocol: BigInt): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0xbcb6e522' +
        evm.encode([
          EvmEncodeParam.fromValue('uint128', flashLoanPremiumTotal),
          EvmEncodeParam.fromValue('uint128', flashLoanPremiumToProtocol),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  withdraw(asset: Address, amount: BigInt, to: Address): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x69328dec' +
        evm.encode([
          EvmEncodeParam.fromValue('address', asset),
          EvmEncodeParam.fromValue('uint256', amount),
          EvmEncodeParam.fromValue('address', to),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  withdraw_1(args: Bytes): CallBuilder {
    const encodedData = Bytes.fromHexString('0x8e19899e' + evm.encode([EvmEncodeParam.fromValue('bytes32', args)]))
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }
}

export class EModeCategoryBaseConfiguration {
  readonly ltv: u16
  readonly liquidationThreshold: u16
  readonly liquidationBonus: u16
  readonly label: string

  constructor(ltv: u16, liquidationThreshold: u16, liquidationBonus: u16, label: string) {
    this.ltv = ltv
    this.liquidationThreshold = liquidationThreshold
    this.liquidationBonus = liquidationBonus
    this.label = label
  }

  static parse(data: string): EModeCategoryBaseConfiguration {
    const parts = parseCSVNotNullable(data)
    if (parts.length !== 4) throw new Error('Invalid data for tuple parsing')
    const ltv: u16 = u16.parse(parts[0])
    const liquidationThreshold: u16 = u16.parse(parts[1])
    const liquidationBonus: u16 = u16.parse(parts[2])
    const label: string = parts[3]
    return new EModeCategoryBaseConfiguration(ltv, liquidationThreshold, liquidationBonus, label)
  }

  toEvmEncodeParams(): EvmEncodeParam[] {
    return [
      EvmEncodeParam.fromValue('uint16', BigInt.fromU16(this.ltv)),
      EvmEncodeParam.fromValue('uint16', BigInt.fromU16(this.liquidationThreshold)),
      EvmEncodeParam.fromValue('uint16', BigInt.fromU16(this.liquidationBonus)),
      EvmEncodeParam.fromValue('string', Bytes.fromUTF8(this.label)),
    ]
  }
}

export class ReserveConfigurationMap {
  readonly data: BigInt

  constructor(data: BigInt) {
    this.data = data
  }

  static parse(data: string): ReserveConfigurationMap {
    const parts = parseCSVNotNullable(data)
    if (parts.length !== 1) throw new Error('Invalid data for tuple parsing')
    const data_var: BigInt = BigInt.fromString(parts[0])
    return new ReserveConfigurationMap(data_var)
  }

  toEvmEncodeParams(): EvmEncodeParam[] {
    return [EvmEncodeParam.fromValue('uint256', this.data)]
  }
}

export class CollateralConfig {
  readonly ltv: u16
  readonly liquidationThreshold: u16
  readonly liquidationBonus: u16

  constructor(ltv: u16, liquidationThreshold: u16, liquidationBonus: u16) {
    this.ltv = ltv
    this.liquidationThreshold = liquidationThreshold
    this.liquidationBonus = liquidationBonus
  }

  static parse(data: string): CollateralConfig {
    const parts = parseCSVNotNullable(data)
    if (parts.length !== 3) throw new Error('Invalid data for tuple parsing')
    const ltv: u16 = u16.parse(parts[0])
    const liquidationThreshold: u16 = u16.parse(parts[1])
    const liquidationBonus: u16 = u16.parse(parts[2])
    return new CollateralConfig(ltv, liquidationThreshold, liquidationBonus)
  }

  toEvmEncodeParams(): EvmEncodeParam[] {
    return [
      EvmEncodeParam.fromValue('uint16', BigInt.fromU16(this.ltv)),
      EvmEncodeParam.fromValue('uint16', BigInt.fromU16(this.liquidationThreshold)),
      EvmEncodeParam.fromValue('uint16', BigInt.fromU16(this.liquidationBonus)),
    ]
  }
}

export class EModeCategoryLegacy {
  readonly ltv: u16
  readonly liquidationThreshold: u16
  readonly liquidationBonus: u16
  readonly priceSource: Address
  readonly label: string

  constructor(ltv: u16, liquidationThreshold: u16, liquidationBonus: u16, priceSource: Address, label: string) {
    this.ltv = ltv
    this.liquidationThreshold = liquidationThreshold
    this.liquidationBonus = liquidationBonus
    this.priceSource = priceSource
    this.label = label
  }

  static parse(data: string): EModeCategoryLegacy {
    const parts = parseCSVNotNullable(data)
    if (parts.length !== 5) throw new Error('Invalid data for tuple parsing')
    const ltv: u16 = u16.parse(parts[0])
    const liquidationThreshold: u16 = u16.parse(parts[1])
    const liquidationBonus: u16 = u16.parse(parts[2])
    const priceSource: Address = Address.fromString(parts[3])
    const label: string = parts[4]
    return new EModeCategoryLegacy(ltv, liquidationThreshold, liquidationBonus, priceSource, label)
  }

  toEvmEncodeParams(): EvmEncodeParam[] {
    return [
      EvmEncodeParam.fromValue('uint16', BigInt.fromU16(this.ltv)),
      EvmEncodeParam.fromValue('uint16', BigInt.fromU16(this.liquidationThreshold)),
      EvmEncodeParam.fromValue('uint16', BigInt.fromU16(this.liquidationBonus)),
      EvmEncodeParam.fromValue('address', this.priceSource),
      EvmEncodeParam.fromValue('string', Bytes.fromUTF8(this.label)),
    ]
  }
}

export class ReserveDataLegacy {
  readonly configuration: ReserveConfigurationMap
  readonly liquidityIndex: BigInt
  readonly currentLiquidityRate: BigInt
  readonly variableBorrowIndex: BigInt
  readonly currentVariableBorrowRate: BigInt
  readonly currentStableBorrowRate: BigInt
  readonly lastUpdateTimestamp: BigInt
  readonly id: u16
  readonly aTokenAddress: Address
  readonly stableDebtTokenAddress: Address
  readonly variableDebtTokenAddress: Address
  readonly interestRateStrategyAddress: Address
  readonly accruedToTreasury: BigInt
  readonly unbacked: BigInt
  readonly isolationModeTotalDebt: BigInt

  constructor(
    configuration: ReserveConfigurationMap,
    liquidityIndex: BigInt,
    currentLiquidityRate: BigInt,
    variableBorrowIndex: BigInt,
    currentVariableBorrowRate: BigInt,
    currentStableBorrowRate: BigInt,
    lastUpdateTimestamp: BigInt,
    id: u16,
    aTokenAddress: Address,
    stableDebtTokenAddress: Address,
    variableDebtTokenAddress: Address,
    interestRateStrategyAddress: Address,
    accruedToTreasury: BigInt,
    unbacked: BigInt,
    isolationModeTotalDebt: BigInt
  ) {
    this.configuration = configuration
    this.liquidityIndex = liquidityIndex
    this.currentLiquidityRate = currentLiquidityRate
    this.variableBorrowIndex = variableBorrowIndex
    this.currentVariableBorrowRate = currentVariableBorrowRate
    this.currentStableBorrowRate = currentStableBorrowRate
    this.lastUpdateTimestamp = lastUpdateTimestamp
    this.id = id
    this.aTokenAddress = aTokenAddress
    this.stableDebtTokenAddress = stableDebtTokenAddress
    this.variableDebtTokenAddress = variableDebtTokenAddress
    this.interestRateStrategyAddress = interestRateStrategyAddress
    this.accruedToTreasury = accruedToTreasury
    this.unbacked = unbacked
    this.isolationModeTotalDebt = isolationModeTotalDebt
  }

  static parse(data: string): ReserveDataLegacy {
    const parts = parseCSVNotNullable(data)
    if (parts.length !== 15) throw new Error('Invalid data for tuple parsing')
    const configuration: ReserveConfigurationMap = ReserveConfigurationMap.parse(parts[0])
    const liquidityIndex: BigInt = BigInt.fromString(parts[1])
    const currentLiquidityRate: BigInt = BigInt.fromString(parts[2])
    const variableBorrowIndex: BigInt = BigInt.fromString(parts[3])
    const currentVariableBorrowRate: BigInt = BigInt.fromString(parts[4])
    const currentStableBorrowRate: BigInt = BigInt.fromString(parts[5])
    const lastUpdateTimestamp: BigInt = BigInt.fromString(parts[6])
    const id: u16 = u16.parse(parts[7])
    const aTokenAddress: Address = Address.fromString(parts[8])
    const stableDebtTokenAddress: Address = Address.fromString(parts[9])
    const variableDebtTokenAddress: Address = Address.fromString(parts[10])
    const interestRateStrategyAddress: Address = Address.fromString(parts[11])
    const accruedToTreasury: BigInt = BigInt.fromString(parts[12])
    const unbacked: BigInt = BigInt.fromString(parts[13])
    const isolationModeTotalDebt: BigInt = BigInt.fromString(parts[14])
    return new ReserveDataLegacy(
      configuration,
      liquidityIndex,
      currentLiquidityRate,
      variableBorrowIndex,
      currentVariableBorrowRate,
      currentStableBorrowRate,
      lastUpdateTimestamp,
      id,
      aTokenAddress,
      stableDebtTokenAddress,
      variableDebtTokenAddress,
      interestRateStrategyAddress,
      accruedToTreasury,
      unbacked,
      isolationModeTotalDebt
    )
  }

  toEvmEncodeParams(): EvmEncodeParam[] {
    return [
      EvmEncodeParam.fromValues('()', this.configuration.toEvmEncodeParams()),
      EvmEncodeParam.fromValue('uint128', this.liquidityIndex),
      EvmEncodeParam.fromValue('uint128', this.currentLiquidityRate),
      EvmEncodeParam.fromValue('uint128', this.variableBorrowIndex),
      EvmEncodeParam.fromValue('uint128', this.currentVariableBorrowRate),
      EvmEncodeParam.fromValue('uint128', this.currentStableBorrowRate),
      EvmEncodeParam.fromValue('uint40', this.lastUpdateTimestamp),
      EvmEncodeParam.fromValue('uint16', BigInt.fromU16(this.id)),
      EvmEncodeParam.fromValue('address', this.aTokenAddress),
      EvmEncodeParam.fromValue('address', this.stableDebtTokenAddress),
      EvmEncodeParam.fromValue('address', this.variableDebtTokenAddress),
      EvmEncodeParam.fromValue('address', this.interestRateStrategyAddress),
      EvmEncodeParam.fromValue('uint128', this.accruedToTreasury),
      EvmEncodeParam.fromValue('uint128', this.unbacked),
      EvmEncodeParam.fromValue('uint128', this.isolationModeTotalDebt),
    ]
  }
}

export class ReserveData {
  readonly configuration: ReserveConfigurationMap
  readonly liquidityIndex: BigInt
  readonly currentLiquidityRate: BigInt
  readonly variableBorrowIndex: BigInt
  readonly currentVariableBorrowRate: BigInt
  readonly __deprecatedStableBorrowRate: BigInt
  readonly lastUpdateTimestamp: BigInt
  readonly id: u16
  readonly liquidationGracePeriodUntil: BigInt
  readonly aTokenAddress: Address
  readonly __deprecatedStableDebtTokenAddress: Address
  readonly variableDebtTokenAddress: Address
  readonly interestRateStrategyAddress: Address
  readonly accruedToTreasury: BigInt
  readonly unbacked: BigInt
  readonly isolationModeTotalDebt: BigInt
  readonly virtualUnderlyingBalance: BigInt

  constructor(
    configuration: ReserveConfigurationMap,
    liquidityIndex: BigInt,
    currentLiquidityRate: BigInt,
    variableBorrowIndex: BigInt,
    currentVariableBorrowRate: BigInt,
    __deprecatedStableBorrowRate: BigInt,
    lastUpdateTimestamp: BigInt,
    id: u16,
    liquidationGracePeriodUntil: BigInt,
    aTokenAddress: Address,
    __deprecatedStableDebtTokenAddress: Address,
    variableDebtTokenAddress: Address,
    interestRateStrategyAddress: Address,
    accruedToTreasury: BigInt,
    unbacked: BigInt,
    isolationModeTotalDebt: BigInt,
    virtualUnderlyingBalance: BigInt
  ) {
    this.configuration = configuration
    this.liquidityIndex = liquidityIndex
    this.currentLiquidityRate = currentLiquidityRate
    this.variableBorrowIndex = variableBorrowIndex
    this.currentVariableBorrowRate = currentVariableBorrowRate
    this.__deprecatedStableBorrowRate = __deprecatedStableBorrowRate
    this.lastUpdateTimestamp = lastUpdateTimestamp
    this.id = id
    this.liquidationGracePeriodUntil = liquidationGracePeriodUntil
    this.aTokenAddress = aTokenAddress
    this.__deprecatedStableDebtTokenAddress = __deprecatedStableDebtTokenAddress
    this.variableDebtTokenAddress = variableDebtTokenAddress
    this.interestRateStrategyAddress = interestRateStrategyAddress
    this.accruedToTreasury = accruedToTreasury
    this.unbacked = unbacked
    this.isolationModeTotalDebt = isolationModeTotalDebt
    this.virtualUnderlyingBalance = virtualUnderlyingBalance
  }

  static parse(data: string): ReserveData {
    const parts = parseCSVNotNullable(data)
    if (parts.length !== 17) throw new Error('Invalid data for tuple parsing')
    const configuration: ReserveConfigurationMap = ReserveConfigurationMap.parse(parts[0])
    const liquidityIndex: BigInt = BigInt.fromString(parts[1])
    const currentLiquidityRate: BigInt = BigInt.fromString(parts[2])
    const variableBorrowIndex: BigInt = BigInt.fromString(parts[3])
    const currentVariableBorrowRate: BigInt = BigInt.fromString(parts[4])
    const __deprecatedStableBorrowRate: BigInt = BigInt.fromString(parts[5])
    const lastUpdateTimestamp: BigInt = BigInt.fromString(parts[6])
    const id: u16 = u16.parse(parts[7])
    const liquidationGracePeriodUntil: BigInt = BigInt.fromString(parts[8])
    const aTokenAddress: Address = Address.fromString(parts[9])
    const __deprecatedStableDebtTokenAddress: Address = Address.fromString(parts[10])
    const variableDebtTokenAddress: Address = Address.fromString(parts[11])
    const interestRateStrategyAddress: Address = Address.fromString(parts[12])
    const accruedToTreasury: BigInt = BigInt.fromString(parts[13])
    const unbacked: BigInt = BigInt.fromString(parts[14])
    const isolationModeTotalDebt: BigInt = BigInt.fromString(parts[15])
    const virtualUnderlyingBalance: BigInt = BigInt.fromString(parts[16])
    return new ReserveData(
      configuration,
      liquidityIndex,
      currentLiquidityRate,
      variableBorrowIndex,
      currentVariableBorrowRate,
      __deprecatedStableBorrowRate,
      lastUpdateTimestamp,
      id,
      liquidationGracePeriodUntil,
      aTokenAddress,
      __deprecatedStableDebtTokenAddress,
      variableDebtTokenAddress,
      interestRateStrategyAddress,
      accruedToTreasury,
      unbacked,
      isolationModeTotalDebt,
      virtualUnderlyingBalance
    )
  }

  toEvmEncodeParams(): EvmEncodeParam[] {
    return [
      EvmEncodeParam.fromValues('()', this.configuration.toEvmEncodeParams()),
      EvmEncodeParam.fromValue('uint128', this.liquidityIndex),
      EvmEncodeParam.fromValue('uint128', this.currentLiquidityRate),
      EvmEncodeParam.fromValue('uint128', this.variableBorrowIndex),
      EvmEncodeParam.fromValue('uint128', this.currentVariableBorrowRate),
      EvmEncodeParam.fromValue('uint128', this.__deprecatedStableBorrowRate),
      EvmEncodeParam.fromValue('uint40', this.lastUpdateTimestamp),
      EvmEncodeParam.fromValue('uint16', BigInt.fromU16(this.id)),
      EvmEncodeParam.fromValue('uint40', this.liquidationGracePeriodUntil),
      EvmEncodeParam.fromValue('address', this.aTokenAddress),
      EvmEncodeParam.fromValue('address', this.__deprecatedStableDebtTokenAddress),
      EvmEncodeParam.fromValue('address', this.variableDebtTokenAddress),
      EvmEncodeParam.fromValue('address', this.interestRateStrategyAddress),
      EvmEncodeParam.fromValue('uint128', this.accruedToTreasury),
      EvmEncodeParam.fromValue('uint128', this.unbacked),
      EvmEncodeParam.fromValue('uint128', this.isolationModeTotalDebt),
      EvmEncodeParam.fromValue('uint128', this.virtualUnderlyingBalance),
    ]
  }
}

export class GetUserAccountDataOutputs {
  readonly totalCollateralBase: BigInt
  readonly totalDebtBase: BigInt
  readonly availableBorrowsBase: BigInt
  readonly currentLiquidationThreshold: BigInt
  readonly ltv: BigInt
  readonly healthFactor: BigInt

  constructor(
    totalCollateralBase: BigInt,
    totalDebtBase: BigInt,
    availableBorrowsBase: BigInt,
    currentLiquidationThreshold: BigInt,
    ltv: BigInt,
    healthFactor: BigInt
  ) {
    this.totalCollateralBase = totalCollateralBase
    this.totalDebtBase = totalDebtBase
    this.availableBorrowsBase = availableBorrowsBase
    this.currentLiquidationThreshold = currentLiquidationThreshold
    this.ltv = ltv
    this.healthFactor = healthFactor
  }

  static parse(data: string): GetUserAccountDataOutputs {
    const parts = parseCSVNotNullable(data)
    if (parts.length !== 6) throw new Error('Invalid data for tuple parsing')
    const totalCollateralBase: BigInt = BigInt.fromString(parts[0])
    const totalDebtBase: BigInt = BigInt.fromString(parts[1])
    const availableBorrowsBase: BigInt = BigInt.fromString(parts[2])
    const currentLiquidationThreshold: BigInt = BigInt.fromString(parts[3])
    const ltv: BigInt = BigInt.fromString(parts[4])
    const healthFactor: BigInt = BigInt.fromString(parts[5])
    return new GetUserAccountDataOutputs(
      totalCollateralBase,
      totalDebtBase,
      availableBorrowsBase,
      currentLiquidationThreshold,
      ltv,
      healthFactor
    )
  }

  toEvmEncodeParams(): EvmEncodeParam[] {
    return [
      EvmEncodeParam.fromValue('uint256', this.totalCollateralBase),
      EvmEncodeParam.fromValue('uint256', this.totalDebtBase),
      EvmEncodeParam.fromValue('uint256', this.availableBorrowsBase),
      EvmEncodeParam.fromValue('uint256', this.currentLiquidationThreshold),
      EvmEncodeParam.fromValue('uint256', this.ltv),
      EvmEncodeParam.fromValue('uint256', this.healthFactor),
    ]
  }
}
