// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE MANUALLY.

import {
  Address,
  BigInt,
  Bytes,
  CallBuilder,
  ChainId,
  environment,
  evm,
  EvmDecodeParam,
  EvmEncodeParam,
} from '@mimicprotocol/lib-ts'

export class ERC20 {
  private _address: Address
  private _chainId: ChainId
  private _timestamp: Date | null

  constructor(address: Address, chainId: ChainId, timestamp: Date | null = null) {
    this._address = address
    this._chainId = chainId
    this._timestamp = timestamp
  }

  get address(): Address {
    return this._address.clone()
  }

  get chainId(): ChainId {
    return this._chainId
  }

  get timestamp(): Date | null {
    return this._timestamp ? new Date(changetype<Date>(this._timestamp).getTime()) : null
  }

  name(): string {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x06fdde03')
    const decodedResponse = evm.decode(new EvmDecodeParam('string', response))
    return decodedResponse
  }

  approve(_spender: Address, _value: BigInt): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x095ea7b3' +
        evm.encode([EvmEncodeParam.fromValue('address', _spender), EvmEncodeParam.fromValue('uint256', _value)])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  totalSupply(): BigInt {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x18160ddd')
    const decodedResponse = evm.decode(new EvmDecodeParam('uint256', response))
    return BigInt.fromString(decodedResponse)
  }

  transferFrom(_from: Address, _to: Address, _value: BigInt): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0x23b872dd' +
        evm.encode([
          EvmEncodeParam.fromValue('address', _from),
          EvmEncodeParam.fromValue('address', _to),
          EvmEncodeParam.fromValue('uint256', _value),
        ])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  decimals(): u8 {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x313ce567')
    const decodedResponse = evm.decode(new EvmDecodeParam('uint8', response))
    return u8.parse(decodedResponse)
  }

  balanceOf(_owner: Address): BigInt {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0x70a08231' + evm.encode([EvmEncodeParam.fromValue('address', _owner)])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('uint256', response))
    return BigInt.fromString(decodedResponse)
  }

  symbol(): string {
    const response = environment.contractCall(this._address, this._chainId, this._timestamp, '0x95d89b41')
    const decodedResponse = evm.decode(new EvmDecodeParam('string', response))
    return decodedResponse
  }

  transfer(_to: Address, _value: BigInt): CallBuilder {
    const encodedData = Bytes.fromHexString(
      '0xa9059cbb' + evm.encode([EvmEncodeParam.fromValue('address', _to), EvmEncodeParam.fromValue('uint256', _value)])
    )
    return CallBuilder.forChain(this._chainId).addCall(this._address, encodedData)
  }

  allowance(_owner: Address, _spender: Address): BigInt {
    const response = environment.contractCall(
      this._address,
      this._chainId,
      this._timestamp,
      '0xdd62ed3e' +
        evm.encode([EvmEncodeParam.fromValue('address', _owner), EvmEncodeParam.fromValue('address', _spender)])
    )
    const decodedResponse = evm.decode(new EvmDecodeParam('uint256', response))
    return BigInt.fromString(decodedResponse)
  }
}
